package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"strings"

	"github.com/xmidt-org/webpa-common/v2/resource"
)

const (
	DefaultIssuer      = "test"
	DefaultBits        = 4096
	DefaultBindAddress = ":8080"
)

var (
	ErrorNoKeys          = errors.New("No keys found in configuration")
	ErrorBlankKeyId      = errors.New("Blank key identifiers are not allowed")
	ErrorInvalidKeyId    = errors.New("Key identifiers cannot have leading or trailing whitespace")
	ErrorNoConfiguration = errors.New("A configuration file is required")
)

// Configuration provides the basic, JSON-marshallable configuration for
// the keyserver.
type Configuration struct {
	// Issuer is the string used for the iss field for any JWTs issued
	// by this server.  If not supplied, DefaultIssuer is used.
	Issuer string `json:"issuer"`

	// BindAddress is the local address on which the server listens
	BindAddress string `json:"bindAddress"`

	// Keys stores information about all the keys known to this server.
	Keys map[string]*resource.Factory `json:"keys"`

	// Bits is the bit length of any keys generated by the server.
	// If this value is non-positive, DefaultBits is used
	Bits int `json:"bits"`

	// Generate is a list of key identifiers which will be generated
	// each time this server starts.
	Generate []string `json:"generate"`
}

func (c *Configuration) Validate() error {
	if len(c.Keys) == 0 && len(c.Generate) == 0 {
		return ErrorNoKeys
	}

	for keyID := range c.Keys {
		trimmedKeyId := strings.TrimSpace(keyID)
		if len(trimmedKeyId) == 0 {
			return ErrorBlankKeyId
		} else if trimmedKeyId != keyID {
			return ErrorInvalidKeyId
		}
	}

	for _, keyID := range c.Generate {
		trimmedKeyId := strings.TrimSpace(keyID)
		if len(trimmedKeyId) == 0 {
			return ErrorBlankKeyId
		} else if trimmedKeyId != keyID {
			return ErrorInvalidKeyId
		}

		if _, ok := c.Keys[keyID]; ok {
			return fmt.Errorf("Key %s is ambiguous: it occurs in keys and generate", keyID)
		}
	}

	return nil
}

func ParseConfiguration(configurationFileName string) (*Configuration, error) {
	if len(configurationFileName) == 0 {
		return nil, ErrorNoConfiguration
	}

	contents, err := ioutil.ReadFile(configurationFileName)
	if err != nil {
		return nil, err
	}

	var configuration Configuration
	err = json.Unmarshal(contents, &configuration)
	if err != nil {
		return nil, err
	}

	return &configuration, nil
}
